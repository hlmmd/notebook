# effective c++

## 导读

explicit禁止隐式的类型转换。尽可能将构造函数申明成explicit

## 让自己习惯c++

### 01：视c++为一个语言联邦 

内置类型 copy by value比copy by reference效率高

### 02：尽量以const,enum,inline替换#define

用编译器替代预处理器

### 03：尽可能地使用const

const在*左边：指向常量

const在*右边：常指针

const 成员函数 mutable修饰符，表示变量可以在const函数中修改

const可以帮助编译器判断错误。

当const和non-const成员函数有着实质等价实现时，令non-const调用const版本可以避免代码重复

### 04:确定对象被使用前已先被初始化

构造函数的赋值和初始化

在函数体内为赋值，使用成员初始值列称为初始化。

初始化列表通常效率更高

const或者reference类型的成员变量必须用初始化列表。所以应当**总是使用初始化列表**

**c++有着固定的成员初始化顺序，class的成员变量总是以其声明的次序被初始化，与初始化列表中的顺序无关**

static对象分为local 和non-local。函数内的static称为local static，其他global、namesapce、class、file作用域内的static称为non-local static。

多个编译单元内的non-local static 对象初始化顺序不确定。

可以通过Singleton模式，将non-local static转换为local static。

注意static在多线程环境下的问题。

## 构造/析构/赋值运算

### 05：了解c++默默编写并调用哪些函数

编译器为一个空类生成：默认构造函数、默认赋值构造函数、默认复制构造函数、析构函数。这些函数都是public且inline的。

在成员变量涉及const和reference时，编译器不会自动生成copy assignment构造函数

### 06：若不想使用编译器自动生成的函数，应当明确拒绝

对于某些类，需要设计成不可copy的，即noncopyable，需要明确拒绝复制构造函数等。可以用delete关键字。

父类构造函数定义为私有，子类不能继承也不会产生默认的构造函数。

### 07：为多态基类声明virtual析构函数

避免类子类derived的成分没有被销毁

在含有virtual函数的类中将析构函数声明为虚函数

而在不含virtual的类中，则不应该声明为虚函数（增加空间占用）

不应该继承没有虚析构函数的类，比如stl中的vector，string等类

抽象类可以定义析构函数为纯虚函数，但同时**必须要给出其定义**,不然运行错误。

因为继承抽象类的类在析构时，先调用子类的析构函数，子类调用父类的虚析构函数

带多态性质的基类应该声明一个virtual析构函数，任何有virtual函数的类其析构函数都应该是虚函数

不带多态性质的基类不应当声明虚析构函数

### 08：别让异常逃离析构函数

如果析构函数可能会抛出异常，那么要提供一个普通函数用来执行该操作。

### 09：绝不在构造和析构过程中调用virtual函数

此时虚函数不起作用，不会调用子类的虚函数。

可以将构造过程中的虚函数改为non-virtual，然后在子类的构造函数中，对父类传递一个带指定参数的构造函数

### 10：令operator=返回一个reference to *this

### 11：在operator中处理“自我赋值”

确保当对象自我赋值时有良好的行为

比较地址、异常处理、copy and swap

确定函数操作多个对象，其中多个对象是同一个对象时，仍然正确。

### 12：复制对象时勿忘其每一个成分

编译器不会提示错误，所以在添加成员变量后要修改copy构造函数

在继承后，要注意父类部分是否被copy了。要调用父类合适的copy函数

不要尝试用一个copy函数去调用另一个copy函数以减少代码。

## 资源管理

### 13：以对象管理资源

RAII，资源取得时机便是初始化时机，构造函数获取资源，析构函数释放资源

shared_ptr管理资源

### 14：在资源管理类中小心copy行为

禁止copy或采用引用计数

### 15：在资源管理类中提供对原始资源的访问

API可能会要求访问class的原始资源，所以RAII class应该提供一个“取得其持有资源”的方法

最好使用显示转换，不要用隐式转换。

### 16：成对使用new和delete时要采取相同形式

使用typedef避免定义数组

new和delete的形式要相同（有无[]，即数组形式）

### 17：以独立语句将newed对象置入智能指针

否则一旦抛出异常，可能导致难以察觉的资源泄露

## 设计与声明



