# MySQL 45 讲

## 01讲 基础架构：一条SQL查询语句是如何执行的

大体来说，MySQL可以分为Server层和存储引擎层两部分。

Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。

### 连接器

第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：

```bash
mysql -h$ip -P$port -u$user -p
```

长连接、短连接

长连接导致内存消耗快 mysql_reset_connection

### 查询缓存

MySQL 8.0版本直接将查询缓存的整块功能删掉了

### 分析器

对sql语法进行分析

### 优化器

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

### 执行器

开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限

## 02讲 日志系统：一条SQL更新语句是如何执行的

redo log（重做日志）和 binlog（归档日志）

* redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。
* redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。
* redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

## 03讲 事务隔离：为什么你改了我还看不见

……

## 04讲 深入浅出索引（上）

索引的出现其实就是为了提高数据查询的效率，就像书的目录一样

使用二叉书作为索引，会导致树过高，从而增加IO次数。所以要使用多叉树

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的

根据叶子节点的内容，索引类型分为主键索引和非主键索引。

主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。

在应用中应该尽量使用主键查询

页分裂与合并

你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。

自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。

插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。

也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。**每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。**

有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：

* 只有一个索引；
* 该索引必须是唯一索引。

## 05讲 深入浅出索引（下）

回表

覆盖索引

最左前缀原则

那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、(b) 这两个索引。

索引下推

## 06讲 全局锁和表锁：给表加个字段怎么有这么多阻碍

全局锁

顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令

官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。

表级锁
MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

表锁的语法是 lock tables … read/write。与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

另一类表级的锁是MDL（metadata lock)。MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

全局锁主要用在逻辑备份过程中。对于全部是InnoDB引擎的库，我建议你选择使用–single-transaction参数，对应用会更友好。

表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有lock tables这样的语句，你需要追查一下，比较可能的情况是：

* 要么是你的系统现在还在用MyISAM这类不支持事务的引擎，那要安排升级换引擎；
* 要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。
* 
MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。

## 07讲 行锁功过：怎么减少行锁对性能的影响

如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放

通过将一行改成逻辑上的多行来减少锁冲突

## 08讲 事务到底是隔离的还是不隔离的

在MySQL里，有两个“视图”的概念：

* 一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view ... ，而它的查询方法与表一样。
* 另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。

一致性读

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：

* 版本未提交，不可见；
* 版本已提交，但是是在视图创建后提交的，不可见；
* 版本已提交，而且是在视图创建前提交的，可见。

更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）

除了update语句外，select语句如果加锁，也是当前读。

如果把事务A的查询语句select * from t where id=1修改一下，加上lock in share mode 或 for update，也都可以读到版本号是101的数据，返回的k的值是3。下面这两个select语句，就是分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。

可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

* 对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
* 对于读提交，查询只承认在语句启动前就已经提交完成的数据；

## 09讲 普通索引和唯一索引，应该怎么选择

change buffer的使用场景

因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。

反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。

回到我们文章开头的问题，普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。

## 10讲 MySQL为什么有时候会选错索引

force index(a)来让优化器强制使用索引a

选择索引是优化器的工作

analyze table t 命令，可以用来重新统计索引信息。

## 11讲 怎么给字符串字段加索引

使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本

```bash
比如，这两个在email字段上创建索引的语句：

alter table SUser add index index1(email);
或
alter table SUser add index index2(email(6));
第一个语句创建的index1索引里面，包含了每个记录的整个字符串；而第二个语句创建的index2索引里面，对于每个记录都是只取前6个字节。
```

```bash
 select count(distinct email) as L from SUser;

 select 
  count(distinct left(email,4)）as L4,
  count(distinct left(email,5)）as L5,
  count(distinct left(email,6)）as L6,
  count(distinct left(email,7)）as L7,
from SUser;
```

对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不够好的情况时，我们要怎么办呢？

第一种方式是使用倒序存储

第二种方式是使用hash字段

```bash
select field_list from t where id_card_crc=crc32('input_id_card_string') and id_card='input_id_card_string'
```

在今天这篇文章中，我跟你聊了聊字符串字段创建索引的场景。我们来回顾一下，你可以使用的方式有：

* 直接创建完整索引，这样可能比较占用空间；
* 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；
* 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；
* 创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。

## 12讲 为什么我的MySQL会“抖”一下

当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。

而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）

* 第一种场景是 InnoDB的redo log写满了。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。
* 系统内存不足
* MySQL认为系统“空闲”的时候
* MySQL正常关闭的情况

## 13讲 为什么表数据删掉一半，表文件大小不变

innodb_file_per_table

delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的

经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。

而重建表，就可以达到这样的目的

alter table A engine=InnoDB

optimize table、analyze table和alter table这三种方式重建表的区别

* 从MySQL 5.6版本开始，alter table t engine = InnoDB（也就是recreate）默认的就是上面图4的流程了；
* analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；
* optimize table t 等于recreate+analyze。

## 14讲 count(*)这么慢，我该怎么办

* MyISAM表虽然count(*)很快，但是不支持事务；
* show table status命令虽然返回很快，但是不准确；
* InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。

用缓存系统保存计数

在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。

在数据库保存计数

不同的count用法

count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。

* 对于count(主键id)来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。
* 对于count(1)来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。

对于count(字段)来说：

* 如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；
* 如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。

也就是前面的第一条原则，server层要什么字段，InnoDB就返回什么字段。

但是count(\*)是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(\*)肯定不是null，按行累加。

```text
count(字段)<count(主键id)<count(1)≈count(*)
```

## 15讲 答疑文章（一）：日志和索引相关问题

……

## 16讲 “orderby”是怎么工作的

select city,name,age from t where city='杭州' order by name limit 1000  ;

全字段排序

* 初始化sort_buffer，确定放入name、city、age这三个字段；
* 从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的ID_X；
* 到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；
* 从索引city取下一个记录的主键id；
* 重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；
* 对sort_buffer中的数据按照字段name做快速排序；
* 按照排序结果取前1000行返回给客户端。

按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数sort_buffer_size

rowid排序

max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。

* 初始化sort_buffer，确定放入两个字段，即name和id；
* 从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的ID_X；
* 到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；
* 从索引city取下一个记录的主键id；
* 重复步骤3、4直到不满足city='杭州’条件为止，也就是图中的ID_Y；
* 对sort_buffer中的数据按照字段name进行排序；
* 遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。

如果能够保证从city这个索引上取出来的行，天然就是按照name递增排序的话，是不是就可以不用再排序了呢？

所以，我们可以在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：

alter table t add index city_user(city, name);

Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多

## 17讲 如何正确地显示随机消息

内存临时表

order by rand()

order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法

磁盘临时表

……

## 18讲 为什么这些SQL语句逻辑相同，性能却差异巨大

对字段做了函数计算，就用不上索引了

对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能

select * from tradelog where id + 1 = 10000这个SQL语句，这个加1操作并不会改变有序性，但是MySQL优化器还是不能用id索引快速定位到9999这一行。所以，需要你在写SQL语句的时候，手动改写成 where id = 10000 -1才可以

**隐式类型转换**

select * from tradelog where tradeid=110717;

tradeid的字段类型是varchar(32)，而输入的参数却是整型，所以需要做类型转换

在MySQL中，字符串和数字做比较的话，是将字符串转换成数字

隐式字符编码转换

对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能

每次你的业务代码升级时，把可能出现的、新的SQL语句explain一下，是一个很好的习惯

## 19讲 为什么我只查一行的语句，也执行这么慢

第一类：查询长时间不返回

等MDL锁
等flush
等行锁

第二类：查询慢

没有索引
……

## 20讲 幻读是什么，幻读有什么问题

“幻读”做一个说明：

在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。

上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。

如何解决幻读？

InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)

……

## 21讲 为什么我只改一行的语句，锁这么多

……

## 22讲 MySQL有哪些“饮鸩止渴”提高性能的方法

短连接风暴

第一种方法：先处理掉那些占着连接但是不工作的线程。
第二种方法：减少连接过程的消耗。–skip-grant-tables跳过验证

慢查询性能问题

* 索引没有设计好； alter table 
* SQL语句没写好；
* MySQL选错了索引。 force index

QPS突增问题

## 23讲 MySQL是怎么保证数据不丢的

只要redo log和binlog保证持久化到磁盘，就能确保MySQL异常重启后，数据可以恢复

binlog的写入机制

…………